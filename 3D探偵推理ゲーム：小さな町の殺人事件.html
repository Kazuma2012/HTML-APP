<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D探偵推理ゲーム：小さな町の殺人事件</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;700&display=swap');
        body {
            font-family: 'Noto Serif JP', serif;
            margin: 0;
            overflow: hidden; /* Canvasが背景になるように */
        }
        #game-ui {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 10;
        }
        #renderer-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        .choice-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body class="bg-slate-900 text-white">

    <!-- 3D Canvas -->
    <div id="renderer-container"></div>

    <!-- Game UI -->
    <div id="game-ui" class="w-full">
        <div class="max-w-3xl mx-auto bg-slate-900/80 backdrop-blur-sm rounded-t-2xl shadow-2xl overflow-hidden border-t-4 border-x-4 border-slate-700">
            <!-- 証拠品リストエリア -->
            <div id="inventory-container" class="bg-slate-950/80 p-3 border-b-4 border-slate-700">
                <h3 class="font-bold text-amber-400 mb-2 text-center text-sm tracking-widest">入手した証拠</h3>
                <ul id="inventory-list" class="flex flex-wrap gap-x-4 gap-y-2 justify-center items-center text-slate-300">
                    <li id="no-evidence">まだ証拠はない...</li>
                </ul>
            </div>
            <div class="p-6 md:p-8">
                <!-- テキスト表示エリア -->
                <div id="text-container" class="mb-6 min-h-[100px] text-lg leading-relaxed">
                    <p>読み込み中...</p>
                </div>
                <!-- 選択肢エリア -->
                <div id="choices-container" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- 選択肢ボタン -->
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- DOM Elements ---
        const textContainer = document.getElementById('text-container');
        const choicesContainer = document.getElementById('choices-container');
        const inventoryList = document.getElementById('inventory-list');
        const noEvidence = document.getElementById('no-evidence');
        const rendererContainer = document.getElementById('renderer-container');

        let inventory = new Set();

        // --- 3D Setup ---
        let scene, camera, renderer, controls;
        let currentSceneObjects = [];

        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e293b); // slate-800

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            rendererContainer.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.minDistance = 2;
            controls.maxDistance = 20;
            controls.target.set(0, 1, 0);

            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function clearScene() {
            currentSceneObjects.forEach(obj => scene.remove(obj));
            currentSceneObjects = [];
        }

        // --- Scene Builders ---
        function buildCrimeScene() {
            clearScene();
            // Room
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), new THREE.MeshStandardMaterial({ color: 0x475569 }));
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            currentSceneObjects.push(floor);

            // Desk
            const desk = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 2), new THREE.MeshStandardMaterial({ color: 0x5a3a22 }));
            desk.position.set(0, 0.75, -5);
            desk.castShadow = true;
            scene.add(desk);
            currentSceneObjects.push(desk);

            // Evidence markers
            const letterGeo = new THREE.PlaneGeometry(0.5, 0.7);
            const letterMat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide });
            const letter = new THREE.Mesh(letterGeo, letterMat);
            letter.position.set(0.5, 1.55, -5);
            scene.add(letter);
            currentSceneObjects.push(letter);

            const knifeGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8);
            const knifeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const knife = new THREE.Mesh(knifeGeo, knifeMat);
            knife.position.set(-3, 0.1, -2);
            knife.rotation.z = Math.PI / 2;
            scene.add(knife);
            currentSceneObjects.push(knife);
            
            // Spotlight
            const spotLight = new THREE.SpotLight(0xffffff, 5, 30, Math.PI * 0.2, 0.5);
            spotLight.position.set(0, 15, 0);
            spotLight.castShadow = true;
            scene.add(spotLight);
            currentSceneObjects.push(spotLight);

            camera.position.set(0, 6, 8);
            controls.target.set(0, 1, -2);
        }

        function buildInterrogationRoom(suspectType) {
            clearScene();
            // Room
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), new THREE.MeshStandardMaterial({ color: 0x334155 }));
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            currentSceneObjects.push(floor);

            // Table
            const table = new THREE.Mesh(new THREE.BoxGeometry(3, 1.2, 1.5), new THREE.MeshStandardMaterial({ color: 0x64748b }));
            table.position.set(0, 0.6, 0);
            table.castShadow = true;
            scene.add(table);
            currentSceneObjects.push(table);

            // Suspect Figure
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshStandardMaterial({ color: suspectType === 'tanaka' ? 0x94a3b8 : 0xa1a1aa }));
            head.position.set(0, 2.4, -2);
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.3, 1.5), new THREE.MeshStandardMaterial({ color: suspectType === 'tanaka' ? 0x475569 : 0x52525b }));
            body.position.set(0, 1.45, -2);
            const suspect = new THREE.Group();
            suspect.add(head);
            suspect.add(body);
            suspect.castShadow = true;
            scene.add(suspect);
            currentSceneObjects.push(suspect);

            // Light
            const light = new THREE.PointLight(0xffffff, 10, 10);
            light.position.set(0, 5, 0);
            light.castShadow = true;
            scene.add(light);
            currentSceneObjects.push(light);

            camera.position.set(0, 3, 5);
            controls.target.set(0, 1.5, 0);
        }
        
        function buildEndingScene(isSuccess) {
            clearScene();
            const color = isSuccess ? 0x15803d : 0xbe123c;
            const light = new THREE.SpotLight(color, 20, 30, Math.PI * 0.3, 1);
            light.position.set(0, 10, 0);
            scene.add(light);
            currentSceneObjects.push(light);
            
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), new THREE.MeshStandardMaterial({ color: 0x0f172a }));
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            currentSceneObjects.push(floor);
        }

        // --- Game Logic ---
        const story = {
            start: {
                text: "静かな港町で、資産家の山下氏が殺害された。あなたは担当刑事として、この事件の捜査を命じられた。まずはどこから調べる？",
                sceneBuilder: buildCrimeScene,
                choices: [
                    { text: "事件現場を詳しく調べる", next: "scene_examine" },
                    { text: "関係者への聞き込みを開始する", next: "scene_interrogate_start" }
                ]
            },
            scene_examine: {
                text: "現場は山下氏の書斎だ。荒らされた様子はないが、床に血痕と倒れたランプがある。机の上には何か手紙のようなものが見える。",
                sceneBuilder: buildCrimeScene,
                choices: [
                    { text: "床の血痕を調べる", next: "scene_examine_blood" },
                    { text: "机の手紙を調べる", next: "scene_examine_letter" }
                ]
            },
            scene_examine_blood: {
                text: "血痕のそばに、小さなフルーツナイフが落ちている。柄には拭き取られたような跡があるが、微かに血が付着しているようだ。重要な証拠になるかもしれない。",
                onEnter: () => addInventory("血の付いたナイフ"),
                sceneBuilder: buildCrimeScene,
                choices: [
                    { text: "机の手紙も調べる", next: "scene_examine_letter" },
                    { text: "現場の調査を終える", next: "scene_interrogate_start" }
                ]
            },
            scene_examine_letter: {
                text: "机の上には、事業の失敗をなじる脅迫状が置かれていた。『お前のせいで全てを失った。必ず報いを受けさせる』と書かれている。差出人の名前はない。",
                onEnter: () => addInventory("脅迫状"),
                sceneBuilder: buildCrimeScene,
                choices: [
                    { text: "床の血痕も調べる", next: "scene_examine_blood" },
                    { text: "現場の調査を終える", next: "scene_interrogate_start" }
                ]
            },
            scene_interrogate_start: {
                text: "捜査線上に2人の容疑者が浮かび上がった。被害者のビジネスパートナーである田中と、被害者に解雇された元秘書の鈴木だ。どちらから話を聞く？",
                sceneBuilder: () => buildInterrogationRoom(),
                choices: [
                    { text: "ビジネスパートナーの田中を尋問する", next: "interrogate_tanaka_1" },
                    { text: "元秘書の鈴木を尋問する", next: "interrogate_suzuki_1" }
                ]
            },
            interrogate_tanaka_1: {
                text: "田中は落ち着いた様子で尋問に応じた。「山下さんとは長年の付き合いでした。事業は順調でしたし、殺す動機なんてありませんよ」と彼は言う。",
                sceneBuilder: () => buildInterrogationRoom('tanaka'),
                choices: [
                    { text: "（脅迫状を持っている場合）この手紙に見覚えは？", next: "interrogate_tanaka_2", condition: () => inventory.has("脅迫状") },
                    { text: "事件当夜のアリバイを聞く", next: "interrogate_tanaka_3" },
                    { text: "鈴木について尋ねる", next: "interrogate_tanaka_4" },
                    { text: "尋問を終える", next: "scene_interrogate_start_after_tanaka" }
                ]
            },
            interrogate_tanaka_2: {
                text: "脅迫状を見せると、田中は顔をしかめた。「これは...ひどい。ですが、私の筆跡ではない。おそらく、彼に恨みを持つ誰かの仕業でしょう。例えば、解雇された鈴木さんとか...」",
                onEnter: () => addInventory("田中は鈴木を疑っている"),
                sceneBuilder: () => buildInterrogationRoom('tanaka'),
                choices: [
                    { text: "事件当夜のアリバイを聞く", next: "interrogate_tanaka_3" },
                    { text: "尋問を終える", next: "scene_interrogate_start_after_tanaka" }
                ]
            },
            interrogate_tanaka_3: {
                text: "「事件があったとされる夜は、ずっと自宅で仕事をしていました。一人だったので証明はできませんが」と田中は答えた。完璧なアリバイはないようだ。",
                onEnter: () => addInventory("田中のアリバイは不確か"),
                sceneBuilder: () => buildInterrogationRoom('tanaka'),
                choices: [
                    { text: "鈴木について尋ねる", next: "interrogate_tanaka_4" },
                    { text: "尋問を終える", next: "scene_interrogate_start_after_tanaka" }
                ]
            },
            interrogate_tanaka_4: {
                text: "「鈴木さんは優秀でしたが、会社の金を使い込んでいる疑惑があり、山下さんが解雇したんです。彼女は相当恨んでいたはずですよ」",
                sceneBuilder: () => buildInterrogationRoom('tanaka'),
                choices: [
                    { text: "尋問を終える", next: "scene_interrogate_start_after_tanaka" }
                ]
            },
            scene_interrogate_start_after_tanaka: {
                text: "田中の尋問を終えた。次はどうする？",
                sceneBuilder: () => buildInterrogationRoom(),
                choices: [
                    { text: "元秘書の鈴木を尋問する", next: "interrogate_suzuki_1" },
                    { text: "（証拠が揃っている場合）犯人を告発する", next: "final_accusation", condition: () => inventory.size >= 2 }
                ]
            },
            interrogate_suzuki_1: {
                text: "鈴木は神経質そうに目を泳がせている。「山下さんにはお世話になりましたが、不当に解雇されたんです！でも、殺したりなんてしていません！」",
                sceneBuilder: () => buildInterrogationRoom('suzuki'),
                choices: [
                    { text: "（血の付いたナイフを持っている場合）このナイフに見覚えは？", next: "interrogate_suzuki_2", condition: () => inventory.has("血の付いたナイフ") },
                    { text: "解雇された理由を聞く", next: "interrogate_suzuki_3" },
                    { text: "田中について尋ねる", next: "interrogate_suzuki_4" },
                    { text: "尋問を終える", next: "scene_interrogate_start_after_suzuki" }
                ]
            },
            interrogate_suzuki_2: {
                text: "ナイフを見せると、鈴木は息を呑んだ。「そ、それは...私が会社の給湯室で使っていたものです...でも、なぜここに...？」彼女は明らかに動揺している。",
                onEnter: () => addInventory("ナイフは鈴木のもの"),
                sceneBuilder: () => buildInterrogationRoom('suzuki'),
                choices: [
                    { text: "解雇された理由を聞く", next: "interrogate_suzuki_3" },
                    { text: "尋問を終える", next: "scene_interrogate_start_after_suzuki" }
                ]
            },
            interrogate_suzuki_3: {
                text: "「横領なんてしていません！あれは田中さんが仕組んだ罠です！彼が会社の金を動かして、私に罪をなすりつけたんです！」と鈴木は涙ながらに訴えた。",
                onEnter: () => addInventory("鈴木は田中が犯人だと主張"),
                sceneBuilder: () => buildInterrogationRoom('suzuki'),
                choices: [
                    { text: "田中について尋ねる", next: "interrogate_suzuki_4" },
                    { text: "尋問を終える", next: "scene_interrogate_start_after_suzuki" }
                ]
            },
            interrogate_suzuki_4: {
                text: "「田中さんは山下さんの事業を乗っ取ろうとしていました。山下さんも最近それに気づいて、彼を警戒していたんです」",
                sceneBuilder: () => buildInterrogationRoom('suzuki'),
                choices: [
                    { text: "尋問を終える", next: "scene_interrogate_start_after_suzuki" }
                ]
            },
            scene_interrogate_start_after_suzuki: {
                text: "鈴木の尋問を終えた。次はどうする？",
                sceneBuilder: () => buildInterrogationRoom(),
                choices: [
                    { text: "ビジネスパートナーの田中を尋問する", next: "interrogate_tanaka_1" },
                    { text: "（証拠が揃っている場合）犯人を告発する", next: "final_accusation", condition: () => inventory.size >= 3 }
                ]
            },
            final_accusation: {
                text: "全ての調査が終わった。君が集めた証拠と証言から、犯人は特定できたか？さあ、告発の時だ。",
                sceneBuilder: () => buildInterrogationRoom(),
                choices: [
                    { text: "犯人は田中だ！", next: "ending_tanaka" },
                    { text: "犯人は鈴木だ！", next: "ending_suzuki" }
                ]
            },
            ending_tanaka: {
                text: "君が田中を突きつけると、彼は観念したように笑った。「そうだ。私がやった。事業を乗っ取ろうとしていることに山下が気づいたからだ。脅迫状で鈴木に罪をなすりつけ、彼女のナイフで...」見事な推理だ。事件は解決した。",
                sceneBuilder: () => buildEndingScene(true),
                isEnding: true,
                condition: () => inventory.has("脅迫状") && inventory.has("ナイフは鈴木のもの") && inventory.has("鈴木は田中が犯人だと主張"),
                fallback: "ending_fail_tanaka"
            },
            ending_suzuki: {
                text: "君が鈴木を犯人だと告発すると、彼女は泣き崩れた。「違う...私じゃない...」その後、真犯人である田中は海外へ高飛びし、事件は迷宮入りとなった。君の推理は間違っていた。",
                sceneBuilder: () => buildEndingScene(false),
                isEnding: true
            },
            ending_fail_tanaka: {
                text: "君は田中を告発したが、決定的な証拠が足りなかった。「馬鹿なことを。証拠でもあるのかね？」彼は弁護士を呼び、君は担当を外された。真犯人は闇の中に消えた。",
                sceneBuilder: () => buildEndingScene(false),
                isEnding: true
            }
        };

        function startGame() {
            showScene('start');
        }

        function showScene(sceneId) {
            const sceneData = story[sceneId];
            
            if (sceneData.isEnding && sceneData.condition && !sceneData.condition()) {
                showScene(sceneData.fallback);
                return;
            }

            if (sceneData.sceneBuilder) {
                sceneData.sceneBuilder();
            }

            textContainer.innerHTML = `<p>${sceneData.text}</p>`;
            choicesContainer.innerHTML = '';

            if (sceneData.onEnter) {
                sceneData.onEnter();
            }

            if (sceneData.isEnding) {
                const restartButton = document.createElement('button');
                restartButton.innerText = 'もう一度プレイする';
                restartButton.className = 'w-full bg-amber-500 hover:bg-amber-600 text-slate-900 font-bold py-3 px-4 rounded-lg transition-all duration-200 choice-button';
                restartButton.onclick = () => {
                    inventory.clear();
                    updateInventory();
                    startGame();
                };
                choicesContainer.appendChild(restartButton);
            } else {
                sceneData.choices.forEach(choice => {
                    if (choice.condition === undefined || choice.condition()) {
                        const button = document.createElement('button');
                        button.innerText = choice.text;
                        button.className = 'w-full bg-slate-700 hover:bg-slate-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 choice-button';
                        button.onclick = () => showScene(choice.next);
                        choicesContainer.appendChild(button);
                    }
                });
            }
        }

        function addInventory(item) {
            inventory.add(item);
            updateInventory();
        }

        function updateInventory() {
            inventoryList.innerHTML = '';
            if (inventory.size === 0) {
                inventoryList.appendChild(noEvidence);
            } else {
                inventory.forEach(item => {
                    const li = document.createElement('li');
                    li.className = "bg-slate-800 px-3 py-1 rounded-full text-sm";
                    li.innerText = `📄 ${item}`;
                    inventoryList.appendChild(li);
                });
            }
        }

        // --- Start Game ---
        init3D();
        startGame();

    </script>
</body>
</html>
